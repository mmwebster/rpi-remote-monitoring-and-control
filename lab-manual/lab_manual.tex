% compile in vim locally with <colon>,<L>,<tab>,<enter>
% \documentclass[12pt]{article}
\documentclass{article}
% document packages
\usepackage[utf8]{inputenc}
% \usepackage[letterpaper,top=1in, bottom=1in, left=1in, right=1in,showframe]{geometry}
\usepackage[letterpaper,top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage{graphicx}
\usepackage[table, dvipsnames]{xcolor}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage{float}
\usepackage[final]{pdfpages}
\usepackage{hyperref}
\usepackage[toc,page]{appendix}
\usepackage[T1]{fontenc}
\usepackage{varwidth}
\usepackage{adjustbox}
\usepackage{tcolorbox}
\usepackage{courier}
\usepackage{caption}
\usepackage{geometry}
\usepackage{gensymb}
\usepackage{siunitx}
\usepackage{titlesec} % paragraph as section
% \usepackage{fontspec}
\tcbuselibrary{listings,skins}
% document settings
\graphicspath{ {resources/} }
\definecolor{my-blue}{rgb}{0,0.3,.8}
\definecolor{light-blue}{RGB}{0,210,255}
\definecolor{light-gray}{gray}{.90}
\definecolor{codestandard}{RGB}{191,204,204}
\definecolor{codegreen}{rgb}{0,0.8,0.3}
\definecolor{codegray}{RGB}{240,240,240}
\definecolor{codepurple}{rgb}{0.88,0,0.92}
\definecolor{bgcolor}{RGB}{55,55,55}
\definecolor{line-num-color}{RGB}{88,88,88}
\definecolor{darkgreen}{RGB}{30,130,30}

\lstdefinestyle{pystyle}{
    backgroundcolor=\color{bgcolor},
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\ttfamily\color{bgcolor},
    stringstyle=\color{codepurple},
    % basicstyle=\footnotesize\ttfamily,
    basicstyle=\linespread{1}\color{codestandard}\ttfamily,
    breakatwhitespace=false,
    breaklines=true,
    captionpos=t,
    keepspaces=true,
    numbers=none,
    numbersep=5pt,
    showspaces=false,
    showstringspaces=false,
    showtabs=true,
    tabsize=2,
    framextopmargin=50pt,
    frame=bottomline,
    framexleftmargin=15pt,
    framextopmargin=0pt,
    framexbottommargin=10pt,
    framerule=0pt,
    frame=tb,
    framesep=15pt,
    xleftmargin=15pt,
    xrightmargin=0pt,
    upquote=true,
    aboveskip={1.5\baselineskip}
}
\DeclareCaptionFormat{listing}{\rule{\textwidth}{0.8pt}\par\vskip1pt#1#2#3}
\captionsetup[lstlisting]{format=listing,singlelinecheck=false, margin=0pt, font={sf},labelsep=space,labelfont=bf}
\renewcommand{\lstlistingname}{Python Code}
\lstset{style=pystyle}
\hypersetup{
  colorlinks,
  linkcolor=my-blue,
  linktoc=all
}

% paragraph to mimic subparagraph header
\setcounter{secnumdepth}{4}
\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}

\newcommand*{\myfont}{\fontfamily{pcr}\selectfont}
\newcommand{\codei}[1]{\colorbox{SpringGreen}{\texttt{#1}}} % inline code
\newcommand{\codeb}[2]{
  \begin{tcolorbox}[width=\textwidth,colback={SpringGreen},title={#1},colbacktitle=darkgreen,coltitle=SpringGreen]
    \myfont
    #2
  \end{tcolorbox}
} % block output
\newcommand{\outputi}[1]{\colorbox{light-gray}{\texttt{#1}}} % inline output
\newcommand{\outputb}[2]{
  \begin{tcolorbox}[width=\textwidth,colback={light-gray},title={#1},colbacktitle=gray,coltitle=light-gray]
    \myfont
    #2
  \end{tcolorbox}
} % block output

\newcommand{\red}[1]{\textcolor{BrickRed}{#1}} % code red text
\newcommand{\loc}[1]{\textit{\textcolor{Black}{\textbf{#1}}}} % location text (w/ gt, lt symbols)
%\newcommand{\loc}[1]{\colorbox{light-blue}{\textcolor{Black}{\textbf{#1}}}}

\newcommand{\imagefig}[2]{
    \begin{figure}[H]
        \centering
        \includegraphics[width=.7\textwidth]{#1}
        \caption{#2}
    \end{figure}
}
\newcommand{\imagefigb}[2]{
    \begin{figure}[H]
        \centering
        \includegraphics[width=\textwidth]{#1}
        \caption{#2}
    \end{figure}
}
\newcommand{\imagefigs}[2]{
    \begin{figure}[H]
        \centering
        \includegraphics[width=.4\textwidth]{#1}
        \caption{#2}
    \end{figure}
}
\newcommand{\todo}[1]{\newline\noindent\colorbox{Yellow}{>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>}\newline\colorbox{Yellow}{\textbf{TODO}}: - #1 \newline \colorbox{Yellow}{<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<}\newline}
\newcommand{\createterm}[3]{
      \item \href{#1}{#2}: #3
} % create a term entry in the `Definitions and Terminology list`. Params: link, name, desc

\newcommand{\note}[1]{\underline{\textit{Note}}: #1}
\newcommand{\pycode}[2]{
  \lstinputlisting[language=Python, caption=#2]{#1}
  \note{When copying the above code, make sure that you do not copy the page number in between the two pages.}
}

\newcommand{\checkpoint}[2]{
    \newline \newline
    \noindent
    \colorbox{Orange}{\textbf{CHECKPOINT}: #1} \newline \colorbox{Orange}{#2}
    \newline \newline
}


% document header
\title{
  UC Santa Cruz, S-Lab \\
%   \colorbox{BurntOrange}{\textbf{Remote Monitoring and Control w/ a Raspberry Pi}} \\
  \textbf{Prototyping a Remote Monitoring and Control System using a Raspberry Pi} \\
  % \colorbox{BurntOrange}{Q: module name?}
  % \textcolor{BurntOrange}{or this}
}
% \author{
%       Advising Professor: Sue Carter \\
%       Author: Milo Webster
%       \textbf{Q: what's the authoring format, do I even put my name?}
%     }
\date{January 16, 2017}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}
  \subsection{Summary}
  This manual will detail the process of designing and implementing a remote monitoring and control system using a Raspberry Pi (RPi). This includes initial config and installation of the OS, communicating with the RPi over a TTL Serial connection, configuring SSH and a public IP to remotely connect, communicating with several sensors over SPI and I2C protocols, sending emails and HTTP requests, and using a Finite State Machine (FSM) to define the autonomous behavior of the RPi.
  The RPi is a very useful instrument for Internet of Things (IoT) type applications, given that it is basically a fully featured computer with a small form factor. As a result, many designs are much easier and quicker to implement on an RPi than on a microcontroller. RPis are ideal for embedded applications in which there is not much constraint on the size and power consumption of the system. Upon completion of this module, you should be able to implement not only the particular system covered in this manual, but also another system of your own design.
  \subsection{Prerequisites}
  It is recommended that you have introductory-level programming experience prior to taking this module.
  %
  % This manual will not cover how to set up a database to store collected data, or how to set up a website or any other method of consuming HTTP requests.
  %
  \subsection{Definitions and terminology}
    \begin{enumerate}
      \createterm{https://en.wikipedia.org/wiki/Raspberry\_Pi}{RPi (Raspberry Pi)}{An awesome prototyping board that features a plethora advances hardware and utilities made incredibly easy to interface with}
      \createterm{https://www.raspberrypi.org/blog/introducing-noobs/}{NOOBS (New Out Of Box Software)}{A software package for the RPi that makes installing the OS on an unconfigured RPi "much, much easier."}
      \createterm{https://en.wikipedia.org/wiki/Secure\_Shell}{SSH (Secure SHell)}{A protocol commonly used for remotely authenticating into a computer}
      \createterm{https://en.wikipedia.org/wiki/Transistor\%E2\%80\%93transistor\_logic}{TTL (Transistor-Transistor Logic)}{A serial protocol used for communication between two systems using only a RX (receive) and TX (transmit) signal}
      \createterm{https://en.wikipedia.org/wiki/Serial\_Peripheral\_Interface\_Bus}{SPI (Serial Peripheral Interface)}{A communications protocol that uses a master-slave architecture. More details can be found.}
      \createterm{https://en.wikipedia.org/wiki/I\%C2\%B2C}{I2C (Inter-Integrated Circuit)}{A communications protocol that allows for multiple master and slave nodes in the network. More details can be found.}
      \createterm{https://en.wikipedia.org/wiki/Finite-state\_machine}{FSM (Finite State Machine)}{A programming design that uses inputs to determine transitions between states, and particular outputs during the process. They are very useful for defining the lifetime of a system and how it will react to all possible inputs. More details can be found.}
      \createterm{https://en.wikipedia.org/wiki/Hypertext\_Transfer\_Protocol\#Request\_methods}{HTTP (Hypertext Transfer Protocol) Request}{The protocol used across the web for the majority of all communications. This manual will detail the process of using a POST request type to send data from the RPi to a remote destination.}
      \createterm{https://en.wikipedia.org/wiki/Command-line\_interface}{Shell CLI (Command-line Interface)}{An instance of a program that allows a user to directly interface with services provided by the OS via a suite of commands.}
      \createterm{https://en.wikipedia.org/wiki/Local\_area\_network}{LAN (Local Area Network)}{A computer network that, among other things, allows computers in the same vicinity to communicate with one another. Wireless printers in your home use the LAN set up by your router to communicate with your personal computer.}
      \createterm{https://en.wikipedia.org/wiki/Wide\_area\_network}{WAN (Wide Area Network)}{A computer network that, among other things, allows computers to communicate with one another, regarldess of geographic proximity. The internet is a form of WAN.}
    \end{enumerate}
  \subsection{Materials}
  \label{sec:materials}
    \underline{Note:} If you are taking this module via the S-Lab at UC Santa Cruz, all of the essential materials will be provided during the first lab session.
    \begin{enumerate}

      \item Essential:
      \begin{enumerate}
        \item \hyperref[sec:vendor-rpi]{Raspberry Pi 3 Model B (Most of this manual will apply to other versions and models as well, however it is tailored to this particular version and model of the RPi.)}
        \item \hyperref[sec:vendor-sd]{Micro SD Card (at least 8GB in size)}
        \item \hyperref[sec:vendor-usbttlserial]{USB to TTL Serial Cable (aka Console Cable)}
        \item \hyperref[sec:vendor-usbmusb]{USB to Micro USB Cable (you most likely already use one for a phone or other device)}
        \item \hyperref[sec:vendor-sensor]{Humidity and Termperature Sensor}
        \item \hyperref[sec:vendor-7seg]{7-Segment Display}
        \item \hyperref[sec:vendor-servo]{Servo Motor}
        \item \hyperref[sec:vendor-breadboard]{Breadboard}
        \item \hyperref[sec:vendor-wires]{Jumper Wires}
        \item \hyperref[sec:vendor-batholder]{4xAA Battery Holder}
        \item HDMI to HDMI cable
        \item Keyboard
        \item Mouse
        \item Monitor
        \item A Mac OSX, Windows, or Linux computer
      \end{enumerate}

      \item Useful:
      \begin{enumerate}
        \item ...
      \end{enumerate}
    \end{enumerate}
    
  \subsection{Learning outcomes}
  After completing this tutorial you should be able to do the following:
  \begin{enumerate}
      \item Configure a Raspberry Pi for headless mode and control it over a serial connection to your computer
      \item Connect to and run operations on your Raspberry Pi over LAN and WAN via SSH and SFTP
      \item Communicate over SPI and I2C with sensors and store their inputs
      \item Drive a servo to actuate mechanical systems
      \item Program intelligent, autonomous logic with Finite State Machines (Note that this implementation uses Python's blocking sleep() function for timing events and is therefore not immediately responsive to sudden changes in inputs. Non-blocking style can be implemented using Python's multithreading library)
      \item Collect and remotely transmit (email) sensor data for later analysis
  \end{enumerate}
    
    
\section{Pre-Lab}
\subsection{Basics of Unix shell navigation and interaction}
Before attending your first lab session, please complete items 1-6 of this tutorial \newline (\href{http://linuxcommand.org/lc3\_learning\_the\_shell.php}{http://linuxcommand.org/lc3\_learning\_the\_shell.php}) on the basics on navigation in and interaction with the Unix shell.

\subsection{Basics of programming in Python}
It is recommended, if you do not have prior experience with Python, to complete the "Learn the Basics" portion of this tutorial (
\href{https://www.learnpython.org/en/Welcome}{https://www.learnpython.org/en/Welcome}) to gather a working knowledge of Python.

\section{Day 1: Configuration and Input}
\subsection{Setting up the Raspberry Pi (RPi)}
\underline{\textit{Note}}: Any \outputi{CLI output text} colored in \outputi{\red{red}} indicates that it will likely be different from your.
  \subsubsection{Using NOOBS to install the OS (Raspbian)}
  The RPi comes without any installed or configured OS. Follow the instructions below to use the micro SD card with NOOBS pre-installed to instal and configure Raspbian on the RPi. If you'd prefer formatting your own micro SD card, you can follow this tutorial \href{https://www.raspberrypi.org/help/noobs-setup/}{here}.
  \begin{enumerate}
    \item Place the micro SD card in the slot on the bottom of the RPi
    \item Plug in all peripherals to your RPi over the HDMI and the USB Ports (Monitor, Keyboard, and Mouse)
    \item Plug in the micro USB cable into the RPi's micro USB port
    \item Select and install Raspbian through the NOOBS GUI
  \end{enumerate}
  \underline{\textit{Note}}: Be sure to choose Raspbian as the OS to install on your RPi, as it will be the OS used for the rest of this manual.

  \subsubsection{Some RPi basics}
    \paragraph{Connecting to a wireless network}
    Through the Raspbian GUI, there is a wifi icon in the upper right of the screen with and clicking on this will take you through a straight-forward prompts to connect to a wireless network. If you are currently using your RPi in "Headless" mode (without a monitor..and GUI), \href{https://www.raspberrypi.org/documentation/configuration/wireless/wireless-cli.md}{this guide} details the process of connecting to a wireless network via the command line (command line access is described in the \hyperref[sec:connect-serial]{section 2.3} and \hyperref[sec:connect-ssh]{section 2.4})
    \paragraph{Shutting down}
    \label{sec:shutting-down}
    It is important that the RPi is always properly shutdown prior to being disconnected from a power source. If it is not, there is a chance that the OS and other persisted data on the micro SD card will be corrupted. You can properly shutdown the RPi via command line or the Raspbian GUI (Graphical User Interface):
      \begin{enumerate}
        \item Command Line: Run \codei{sudo shutdown now} and wait until you receive an output of \newline\outputi{[ \red{1837.852002}] reboot: Power down} in the shell before you disconnect the RPi from its power source.
        \item GUI: navigate to \loc{Menu >> Shutdown} and then click on the \textit{Shutdown} option
      \end{enumerate}

  \subsubsection{Wired connection over TTL Serial}
    \label{sec:connect-serial}
    It is often convenient to be able to interface with the RPi with only your personal computer, instead of with the monitor, keyboard, and mouse that were required when installing the OS. A TTL Serial connection between your RPi and computer will allow you to do everything you would normally be able to do through the Raspbian GUI, through the Raspbian CLI via a serial terminal on your computer.
    \paragraph{Enable the interfaces}
    To connect over TTL Serial, we must first enable the Serial interface on the RPi. Later on we will also need the SSH, SPI, and I2C interfaces so we'll enable those now as well. Navigate to \loc{Menu >> Preferences >> Raspberry Pi Configuration} as shown in the Figure 1 below.

    \imagefig{screen1.png}{RPi Configuration at \loc{Menu >> Preferences >> Raspberry Pi Configuration}}

    Next, navigate to the \loc{Interface} tab and enable all of the necessary interfaces (SSH, SPI, I2C, and Serial) as shown in Figure 2 below.
    \imagefig{screen2.png}{Necessary interface configuration for the RPi}

    Now press \textit{OK}, and reboot the RPi by going to \loc{Menu >> Shutdown} and clicking \textit{Reboot}.

    \paragraph{Disable bluetooth to free up GPIO 14 \& 15 (TX, RX)}
    On the Pi 3 Model B, it so happens that the built-in Bluetooth chip consumes GPIO (General-Purpose Input/Output) 14 \& 15 (pins 8 \& 10) that correspond to TX and RX, respectively, that are required for the serial connection. We must now disable this in order to free up these pins. First, open the \textit{Terminal} application to get a CLI Shell into Raspbian. The application can be navigated to by \loc{Menu >> Accessories >> Terminal}. You should now see a window that looks like the following in Figure 3.
    \imagefig{screen3.png}{Raspbian Terminal App (Shell CLI)}

    In the shell, you can enter unix style commands indicated in this manual by \codei{this styling}. Run the following commands to ensure that your RPi is up to date.

    \codeb{Update environment}
    {
      sudo apt-get update \\
      sudo apt-get upgrade \\
      sudo apt-get dist-upgrade \\
      sudo rpi-update
    }

    Now to disable bluetooth, run the following command in order to edit the RPi's config file and stop the BT modem from trying to use UART:

    \codeb{Disable bluetooth: Edit boot config file}
    {
      sudo nano /boot/config.txt
    }

    Then, add the following line to the end of the file:

    \outputb{Disable bluetooth: Text to append to config file}
    {
      dtoverlay=pi3-disable-bt
    }

    Now, after exiting the nano editor, run the following command:

    \codeb{Disable bluetooth: Disable hciuart}
    {
      sudo systemctl disable hciuart
    }

    Finally, reboot the RPi (to allow the changes to take effect) by running \codei{sudo reboot}.

    \paragraph{Download and install the drivers for the TTL Serial cable}
    There are specific drivers required for this protocol that are available for Mac OSX, Windows, and Linux. Follow the appropriate guide below to download and install the drivers for your computer.
    \begin{itemize}
      \item \href{https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/software-installation-mac}{\textit{\textbf{Mac OSX}} Download/Installation Guide for TTL Serial Driver}
      \item \href{https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/software-installation-windows}{\textit{\textbf{Windows}} Download/Installation Guide for TTL Serial Driver}
      \item \href{https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/software-installation-linux}{\textit{\textbf{Linux}} Download/Installation Guide for TTL Serial Driver}
    \end{itemize}

    \paragraph{Connect the leads and USB port}
    Now, connect each of the four color-coded leads on the TTL Serial cable to their corresponding pins on the RPi's GPIO header. VCC and GND have multiple options for pins, but TX and RX must be placed on GPIO 14 \& 15. The following is a recommended configuration of the TTL Serial cable's leads:
    \begin{itemize}
      \item \textbf{VCC}: Pin \textbf{4} (5V)
      \item \textbf{GND}: Pin \textbf{6} (Ground)
      \item \textbf{TX }: Pin \textbf{8} (GPIO 14)
      \item \textbf{RX }: Pin \textbf{10} (GPIO 15)
    \end{itemize}
    \underline{\textit{Note}}: Depending on where you purchased your cable, the leads are likely colored for \textbf{TX either white or orange} and \textbf{RX either green or yellow}. VCC is always colored red and GND always black.
    \imagefig{rpi3mb-gpio.png}{Raspberry Pi 3 Model B, GPIO header. Photo credit: \href{http://blog.mcmelectronics.com/post/Raspberry-Pi-3-GPIO-Pin-Layout}{mcmelectronics.com}}

    \checkpoint{Before proceeding, please confirm with your lab instructor that you have correctly}{wired your TTL Serial Cable.}

    \textbf{DO NOT SUPPLY POWER OVER BOTH THE MICRO USB AND THE SERIAL CABLE} and double check that the leads of the serial cable are connected properly; the RPi is not especially tolerant when it comes to power and can be fried somewhat easily. Once you're certain the leads of the cable are properly connected, plug the USB into your computer and you should see the RPi's power LED indicator turn on as it did when supplied power over micro USB.

    \paragraph{Testing the connection}
    Now, all that's neccessary to connect over the serial connection is to open a serial terminal and connect to the right port using \textbf{115200 baud}. \textit{Screen} is a command line serial interface and comes with recent releases of \textit{Mac OSX}. It does not come with all distributions of \textit{Linux}, but can easily be installed using \codei{sudo apt-get install screen}. \textit{Windows} requires an application called \textit{PuTTY} and the process takes slightly longer. \href{https://learn.adafruit.com/adafruits-raspberry-pi-lesson-5-using-a-console-cable/test-and-configure}{This is a guide detailing the complete steps for each operating system.}
    \newline\newline
    \underline{Note:} As indicated in the aformentioned guide, the login credentials for a user with root privileges on the RPi is by default:
    \begin{itemize}
      \item username: \textbf{pi}
      \item password: \textbf{raspberry}
    \end{itemize}
    \subsubsection{Wireless connection over LAN via local IP \& SSH}
    \label{sec:connect-ssh}
    Sometimes it is more convenient to connect to the RPi over SSH because of the extra features it provides. Included in these features is a protocol called SFTP (SSH File Transfer Protocol) that makes it quick and easy to transfer files between your computer and the RPi. To connec to your RPi in this manner requires the use of a LAN (Local Area Network) on which both your personal computer and the RPi must be one.
    \newline
    \newline
    \underline{\textit{Note}}: This method only works for local networks and cannot be used to connect to your RPi if both your computer and the RPi are not connected to the same network. See \hyperref[sec:connect-sshwan]{the following section} if you wish to connect to your RPi from a different network than what the RPi is on.

    \paragraph{Connect the RPi to a local network}
    To connect over SSH or SFTP, the RPi must first be connected to a local network (which was done earlier in this manual)
    \paragraph{Determine the RPi's IP address}
    After connecting to your local network, the RPi will be allocated an IP address. To find this, connect to the RPi over serial (as described in \hyperref[sec:connect-serial]{section 2.2}). Then, in the command line run \codei{hostname -I}. This should output something of the form \outputi{\red{\textbf{10.0.1.26} 2601:1c0:5101:1ea8:e2af:7dc1:9da6:2025}}, where the bolded portion is the RPi's IP address. Copy this address to your clipboard.
    \paragraph{Making the SSH connection}
    In the command line on your computer, SSH into the RPi by running \codei{ssh pi@\red{<IP-ADDRESS>}} where \codei{\red{<IP-ADDRESS>}} is replaced by the IP address you copied earlier. After running the command, you will be prompted for the password which, unless you changed it, will be its default of \textbf{raspberry}. Once authenticating, you have access command line access to the RPi (same as was achieved over the TTL Serial cable). This connection is, however, dependent on a the existence of a network, wheras the serial connection is not. A complete guide for this method can be found \href{https://www.raspberrypi.org/documentation/remote-access/ssh/}{here}.
    \paragraph{Using SFTP to transfer files}
    In a similar way, you can remotely access the RPi over SFTP, which makes file transfer between your computer and the RPi much easier. SFTP into the RPi by running \codei{sftp pi@\red{<IP-ADDRESS>}} in the command line of your computer. Then, you can use some of the standard UNIX commands to navigate through both the file system of the RPi and your computer (except that all commands need to be prefaced with \textbf{l} (letter "ell") indicating the local file system). The commands \codei{get} and \codei{put} can be used to transfer files from the RPi and to the RPi, respectively. A complete guide to using this method can be found \href{https://www.digitalocean.com/community/tutorials/how-to-use-sftp-to-securely-transfer-files-with-a-remote-server}{here}.

  \subsubsection{Wireless connection over WAN via Weaved \& SSH}
  \label{sec:connect-sshwan}
    Often times you are not in range of the network your RPi is on but still want to connect to it. In this case, where you need to connect to your RPi through a WAN (Wide Area Network), you can use a service called Weaved (\href{https://www.weaved.com}{https://www.weaved.com}). Weaved handles all the potential security risks involved with opening your RPi to the public, and allows you to SSH into it just as is possible through a LAN.
    \paragraph{Setup an account at Weaved.com}
    First, setup a free account at \href{https://developer.weaved.com/portal/index.php}{https://developer.weaved.com/portal/index.php}.
    \paragraph{Install Weaved on the RPi}
    Next, download and install Weaved onto the RPi but running the following code in the command line (after accessing the command line of the RPi through TTL Serial or LAN SSH):
    \codeb{Download and install Weaved to the RPi}
    {
      sudo apt-get update \\
      sudo apt-get install weavedconnectd \\
      sudo weavedinstaller \\
    }
    After running the last command, you will be taken through a series of prompts in order to configure Weaved on your RPi. Perform the following, in the following order, in order to configure Weaved for SSH on your RPi:
    \begin{enumerate}
      \item Select \#1 \textit{Sign in to existing account}
      \item Enter your Weaved login credentials
      \item Select \#1: \textit{Attach/reinstall Weaved to a Service}
      \item Select \#1: \textit{SSH on default port 22}
      \item Enter: y (for "yes continue")
      \item Enter name: SSH-Pi (and then wait for installation to finish)
      \item Select \#3: \textit{Exit}
    \end{enumerate}
    Weaved should now be properly configured on your RPi.
    \paragraph{Connecting to the RPi over SSH with Weaved}
    Follow this procedure to SSH into your RPi with Weaved:
    \begin{enumerate}
      \item Login to your Weaved account here: \href{https://developer.weaved.com/portal/login.php}{https://developer.weaved.com/portal/login.php}.
      \item Click on your service named "SSH-Pi"
      \item Copy the text in the field labeled "For pi username"
      \item Paste this text into the command line of your personal computer and run it
    \end{enumerate}
    You should now be prompted for the password of your RPi's \textit{pi} user, after which you will have a command line into your RPi.
    \note{The host and port copied from Weaved.com are dynamically generated and only valid for 30 minutes (with the free version). To reconnect after 30 minutes, you will have to repeat steps 2 \& 3 above. The paid versions of Weaved extend the lifetime of SSH credentials. Also, they have a free mobile app that in which you can also issue SSH credentials for your RPi.}

\subsection{Sensor inputs}
    \subsubsection{Communicating with the si7021 humidity and temperature sensor (over I2C)}
  The RPi is nothing more than your personal computer if not given the chance to interact with its environment. The 40 pins in the GPIO header are what allow the RPi to do this. They provide a number of interfaces, one of which (Serial) was already implemented earlier in this manual, that can be used to communicate with a variety of sensors. I2C is the protocol that the humidity and temperature sensor (si7021) uses, and so that is how we will implement it in this section.
  \newline\newline\underline{\textit{Note}}: This section is tailored to connecting to the RPi over TTL Serial, however the same procedure can be carried out \hyperref[sec:connect-ssh]{over SSH}. It is also tailored the \textit{GNU nano} editor. \href{http://www.howtogeek.com/howto/42980/the-beginners-guide-to-nano-the-linux-command-line-text-editor/}{You can find out more about how to use nano in this guide.}
    \paragraph{Configuring I2C}
      \label{sec:configuring-i2c}
      I2C must be configured, as by default, it is neither enabled nor is its kernel module loaded at boot time. As a result of some prior steps in this manual, the steps in this section are likely unnecessary, but it's a good idea to go through them anyway. Make sure that you have a serial connection with the RPi. If you're unsure of this, refer back to \hyperref[sec:connect-serial]{section 2.3}.
      \newline
      \indent
      First, make sure that I2C is not blacklisted by inspecting the contents of the file at \loc{/etc/modprobe.d/raspi-blacklist.conf} by running \codei{sudo nano /etc/modprobe.d/raspi-blacklist.conf}. If there is a line of the form \outputi{blacklist i2c-bcm\red{2708}}, comment it out by writing a hash (\#) at the beginning of the line. If there is no line of this form, then I2C is already enabled. You can save and exit \textit{nano} by typing \texttt{\textbf{control-O <enter> control-X}}.
      \newline
      \indent
      Next, make sure that the I2C kernel module is loaded at boot time by running \codei{sudo nano /etc/modules} to open the file and append to it the line \outputi{i2c-dev} if it does not already exist.
      \newline
      \indent
    \paragraph{Install packages and probe the I2C interface}
    Run the following:
    \codeb{Update environment and install necessary packages}{
      sudo apt-get update \\
      sudo apt-get install i2c-tools \\
      sudo apt-get install python-smbus
    }

    Now, in case the \textit{pi} user is not by default a member of the I2C group, run \codei{sudo adduser pi I2C}.
    \newline
    Finally, probe the I2C interface to make sure that everything has been configured properly by running \codei{i2cdetect -y 1}. This should output something of the following form:

    \outputb{I2C interface detection output (si7021 \textbf{NOT} wired)}
    {
      \textcolor{ForestGreen}{pi@raspberrypi:\textasciitilde/Desktop/slab/tmp \$} i2cdetect -y 1 \\
    ...       0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f \\
      00:          -- -- -- -- -- -- -- -- -- -- -- -- -- \\
      10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
      20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
      30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
      40: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
      50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
      60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
      70: -- -- -- -- -- -- -- --
    }

    This output indicates that none of the 128 (hexadecimal 0x0 to 0x7f) I2C addresses are being used (the si7021 sensor is not connected) but the I2C interface has been properly configured.

  \paragraph{Wiring the si7021 sensor to the RPi}
  We must now wire the temperature and humidity sensor to the RPi. To do this, we'll need the breadboard and jumper cables included in the materials list at the beginning of this manual. Using these materials, connect the si7021 to the RPi according to the wiring diagram below. But first, make sure that you are aware of the following:
  \begin{enumerate}
    \item \textbf{DO NOT} change the wiring of your system while the RPi is still powered on. Instead, \hyperref[sec:shutting-down]{shutdown the pi}, then unplug it from the power source. This is done to prevent short circuits and other dangers while re-wiring your system.
    \item \textbf{DO NOT} connect the si7021 or any other 5V intolerant device to a 5V output on the RPi. Many sensors are designed to work using 3.3V, and can be easily fried if this voltage is exceeded.
  \end{enumerate}

    \imagefigb{si7021-wiring-diagram.png}{Wiring diagram for connecting the si7021 to the RPi over I2C}
    \checkpoint{Before proceeding, please confirm with your lab instructor that you have correctly}{wired your si7021 to the RPi.}

  \paragraph{Testing the wiring}
  There are many ways to test for faulty wiring, however in this case, it is easiest to just the I2C interface detection tool to confirm that the si7021 is properly wired. First, plug the Pi back into your computer and get the serial connection running again. Then, run the same command from before \codei{i2cdetect -y 1}. The output should now indicate that there is an I2C device connected using address 0x40, having somethign similar to the following form:
  \outputb{I2C detection output (si7021 wired)}
  {
    \textcolor{ForestGreen}{pi@raspberrypi:\textasciitilde/Desktop/slab/tmp \$ i2cdetect -y 1} \\
    ...  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f \\
    00:          -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    40: 40 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    70: -- -- -- -- -- -- -- --
  }

  If the detection utility does not indicate that I2C address 0x40 is active, double check that you have properly wired the sensor to the RPi. If the problem persists (\textit{i2cdetect} does not indicate address 0x40), it is possible that you have fried the sensor and/or the RPi, but while troubleshooting this should be a last resort.

  \paragraph{Daemonizing the \textit{pigpiod} program}
    Before we can talk with the si7021 from the context of Python (the programming language used in this manual), we must first daemonize the program that coordinates with the Python I2C module to make it easy to communciate with sensors over I2C via Python. In the command line, run the following commands:
    \codeb{Prep the environment and locate \textit{pigpiod}}
    {
      sudo rpi-update     \\
      sudo pkill pigpiod  \\
      whereis pigpiod
    }
    This will output something of the form:
    \outputb{\texttt{whereis pigpiod} command output}
    {
      pi@raspberrypi:\textasciitilde \$ whereis pigpiod \\
      pigpiod: \colorbox{Yellow}{/usr/bin/pigpiod} /usr/man/man1/pigpiod.1.gz
    }
    Now, copy the path this outputs that has a similar form as the portion highlighted above (the path is likely, but not necessarily, defaulted to \loc{/usr/bin/pigpiod}). Then run the following comand:
    \codeb{Open the root crontab}
    {
      sudo crontab -e
    }
    This will now open the root crontab file in which you can indicate that the pigpiod program should be run on reboot. Do this by appending the following line to this file (where you paste in the path you copied where it says <your-path-to-pigpiod>):
    \outputb{Daemonize \textit{pigpiod} command}
    {
      @reboot              <your-path-to-pigpiod>
    }
    Now save the file and exit the editor. To allow the changes to take effect, reboot the RPi by running \codei{sudo reboot} and login again once the prompt appears. Test that the \textit{pigpiod} program was successfully daemonized by running \codei{pgrep pigpiod}. If this outputs a single number (its process id) to the screen, then the program was sucessfully daemonized. If not, review the previous steps to make sure that nothing was missed.


  \paragraph{Talking to the si7021 with Python}
    The next natural step is to talk to the newly installed sensor from the context of a Python script to get back readings for humidity and temperature. In the command line, create and navigate to a workspace for your python code on the desktop by running the follow:
    \codeb{Create and navigate to your workspace}
    {
      mkdir -p \textasciitilde/Desktop/python-code/test-scripts \\
      cd \textasciitilde/Desktop/python-code/test-scripts
    }
    \noindent
    Now create and edit a file using the same \textit{nano} editor used before:
    \codeb{Create si7021 Python testing script file}
    {
      nano si7021-test.py
    }
    \noindent
    Now copy and paste the following code into this file:
    \lstinputlisting[language=Python, caption=Script for testing si7021]{si7021-test-tex.py}
    \underline{\textit{Note}}: When copying the above code, make sure that you do not copy the page number in between the two pages.

    \newline

    \newline

    \noindent
    Now save the file (\textbf{\texttt{control-O <enter> control-X}}) and run the script by executing the following in the command line:
    \codeb{Run the test script for si7021 sensor}{python si7021-test.py}
    This should then continually output relative humdity and temperature readings like the following:
    \outputb{Test script output for si7021 sensor}
    {
      pi@raspberrypi:\textasciitilde/Desktop/python-code/test-scripts\$ python si7021-test.py        \\
      Humidity: 60.91\%, Temperature: 19.33\degree C                                   \\
      Humidity: 60.91\%, Temperature: 19.32\degree C                                   \\
      Humidity: 60.90\%, Temperature: 19.35\degree C                                   \\
      ...
    }
    
\section{Day 2: Local and Remote Output}
\subsection{Sensor outputs}
  In this section, it will be assumed that I2C is already fully configured on your RPi. If this is not the case, refer back to \hyperref[sec:configuring-i2c]{section 3.1.1}. It is now necessary to set up some outputs for this system to get feedback from the sensor and interact with the environment.
  \subsubsection{Communicating with the 7-segment display (over I2C)}
  The 7-segment display (refferred from now on as the seg7) supports a variety of communications protocols, however for convenience, we will use I2C just as for the si7021. If you would like more information about the seg7 used in this manual, its documentation can be found here \newline\href{https://github.com/sparkfun/Serial7SegmentDisplay/wiki/Serial-7-Segment-Display-Datasheet}{https://github.com/sparkfun/Serial7SegmentDisplay/wiki/Serial-7-Segment-Display-Datasheet}.
    \paragraph{Wiring the seg7 display to the RPi}
    First, the seg7 must be wired to the RPi. As with the si7021, we'll need the breadboard and jumper cables included in the materials list at the beginning of this manual. Using these materials, connect the seg7 to the RPi, next to the si7021, according to the wiring diagram below. And again, make sure that you are aware of the following points prior to wiring this system:
    \begin{enumerate}
      \item \textbf{DO NOT} change the wiring of your system while the RPi is still powered on. Instead, \hyperref[sec:shutting-down]{shutdown the pi}, then unplug it from the power source. This is done to prevent short circuits and other dangers while re-wiring your system.
      \item \textbf{DO NOT} connect the si7021 or any other 5V intolerant device to a 5V output on the RPi. Many sensors are designed to work using 3.3V, and can be easily fried if this voltage is exceeded.
    \end{enumerate}
    Some notes for wiring the seg7 display:
    \begin{enumerate}
      \item The seg7 is actually rated to a range of 2.4V to 6V and therefore works with a supply of either 3.3V or 5V from the RPi. We will use 5V, as it results in a brighter display.
      \item The SDA and SCL I2C pins on the seg7 will be connected to the same I2C bus used for the si7021. The design of the 7-bit ID, I2C protocol allows for $2^7$ (128) devices with unique IDs. The seg7 display defaults to an I2C address of 0x71, which does not conflict with the 0x40 address of the si7021.
      \item Make sure that you do not place the seg7 in an upside down orientation on the breadboard. This would result in the the 5V/GND pins being switched with the SCL/SDA pins.
    \end{enumerate}
    \newline
    \noindent
    \imagefigb{si7021-seg7-wiring-diagram.png}{Wiring diagram for connecting the seg7 (along with si7021) to the RPi over I2C}
    \checkpoint{Before proceeding, please confirm with your lab instructor that you have correctly}{wired your si7021 and seg7 display to the RPi.}
  \paragraph{Testing the wiring}
  As with the si7021, we must now check that the seg7 was wired properly to the RPi using the same \textit{i2cdetect} tool in the command line on the RPi. Plug in the RPi back into your computer over the TTL Serial connection and login with the same default Raspbian login credentials for the \textit{pi} user before. Then run the command \codei{i2cdetect -y 1}. The output should now, if the seg7 was wired properly, indicate that there are two I2C devices connected over addresses 0x40 and 0x71, having a similar form as the following:
  \outputb{I2C detection output (seg7 and si7021 both wired)}
 {
    \textcolor{ForestGreen}{pi@raspberrypi:\textasciitilde/Desktop/slab/tmp \$ i2cdetect -y 1} \\
    ...  0  1  2  3  4  5  6  7  8  9  a  b  c  d  e  f \\
    00:          -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    10: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    20: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    30: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    40: 40 -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    50: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    60: -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- \\
    70: -- 71 -- -- -- -- -- --
  }
  If this command does not indicate that address 0x71 is active, double check that the seg7 was wired to the RPi properly.
  \paragraph{Writing to the seg7 with Python}
  The seg7 can display most characters logically displayable on 7 segments. This includes characters such as \textbf{0-9} and \textbf{A-F}, but does not includes characters such as \textbf{v}. There are three basic operations that can be performed on the seg7 display:

  \begin{enumerate}
    \item \underline{Reset}: Turn off all LED segments and return the cursor to the leftmost digit by writing the byte \textbf{0x76}.
    \item \underline{Move Cursor}: Move the cursor (where the next written character will be placed) to a particular position by writing the byte \textbf{0x79}, followed by another byte with a value of \textbf{0-3}. The data (second) byte, indicates the position to move the cursor to, where position 0 is the leftmost digit, and position 3 is the rightmost digit.
    \item \underline{Write Character}: Write a character to the digit at which the cursor is currently at by writing a byte of 0-15 (hex values 0-9,A-F) or a byte corresponding to a character's ASCII value (for example, 'u' or 'E'). As mentioned before, not all characters can be displayed.
  \end{enumerate}

  \linebreak
  \newline
  \underline{\textit{Note}}: The cursor defaults to the leftmost position, however it is a good practice to ensure this position by setting it prior to writing characters to the display.
  \newline
  \noindent

  Now, move to the workspace you created earlier by running the following:
  \codeb{Navigate to your workspace}
  {
    cd \textasciitilde/Desktop/python-code/test-scripts
  }
  \newline
  \noindent
  Then, create and edit a file using the same \textit{nano} editor used before:
  \codeb{Create seg7 Python testing script file}
  {
    nano seg7-test.py
  }
  \newline
  \noindent
  Now, copy and paste the following code into this file:
  \lstinputlisting[language=Python, caption=Script for testing seg7 display]{seg7-test-tex.py}
  \note{When copying the above code, make sure that you do not copy the page number in between the two pages.}

  \newline
  \noindent
  Now save the file (\textbf{\texttt{control-O <enter> control-X}}) and run the script by executing the following in the command line:
  \codeb{Run the test script for seg7 sensor}{python seg7-test.py}
  This should then continually output the lines "Hello" and "Goodbye" like the following:
  \outputb{Test script output for seg7 sensor}
  {
    pi@raspberrypi:\textasciitilde/Desktop/python-code/test-scripts\$ python seg7-test.py        \\
    Hello                                   \\
    Goodbye                                   \\
    Hello                                   \\
    ...
  }
  And you should see the text "HELO" flashing on the 7 segment display that you connected to your RPi.
  \subsubsection{Using the servo motor}
  This section will cover the implementation of a servo motor using PWM (Pulse Width Modulation) via the Python RPi.GPIO package. For more information on controlling servos with PWM, this wikipedia article has a very complete overview: \href{https://en.wikipedia.org/wiki/Servo\_control}{https://en.wikipedia.org/wiki/Servo\_control}. And this contains a collection of helpful PWM resources: \href{https://learn.sparkfun.com/tutorials/pulse-width-modulation/duty-cycle}{https://learn.sparkfun.com/tutorials/pulse-width-modulation/duty-cycle}.

    \paragraph{Overview of controlling the servo with PWM}
    PWM requires is a method of controlling the following properties of a signal in order to digitally vary its voltage or move a servo to a specific degree rotation.
    \begin{enumerate}
      \item \underline{Duty Cycle}: This is the percentage of the signal that is high. A 50\% duty cycle means that the signal will by high 50\% of the time, and low the other 50\%.
      \item \underline{Frequency}: This is the rate of oscillation of the signal from low to high. A common frequency for servos is 50Hz, but this can vary from servo to servo.
    \end{enumerate}

    \paragraph{Wiring the servo motor to the RPi and battery pack}
    Most servo motors have the following pins on them:
    \begin{enumerate}
      \item \underline{VCC}: The servo listed in \hyperref[sec:materials]{Materials} requires a positive supply of 4.5V to 6V
      \item \underline{GND}: This must be tied to GND on both the RPi and battery pack
      \item \underline{Signal}: This carries the PWM control signal with a specified frequency and duty cycle that tells the servo what degree rotation it should be at
    \end{enumerate}
    To wire this system, first prepare the battery pack by placing four AA batteries into the harness. Since the servo used in this manual is rated for 4.5V to 6V, either 3 or 4 AA or AAAs will work, but the battery holder listed in the \hyperref[sec:materials]{Materials} section is designed for 4 AAs.
    \newline
    \indent
    Next, place the male-male header onto the the female leads of the servo. Then, connect the servo, battery pack, and RPi together according to the following wiring diagram (this diagram was made on top of that for the si7021 sensor and seg7 display):
    \imagefigb{si7021-seg7-servo-wiring-diagram-v2.png}{Wiring diagram for connecting the servo \& battery pack (along with si7021 and seg7) to the RPi to control over PWM}
    \checkpoint{Before proceeding, please confirm with your lab instructor that you have correctly}{wired your si7021, seg7 display, and servo to the RPi.}
    \paragraph{Controlling the servo with Python}
    In Python, the servo can be moved to different angles by varying the duty cycle of the 50Hz (the frequency this servo requires) signal. It turns out that the range of duty cycles for this servo is \textasciitilde2.1\% (\textasciitilde210\degree) to \textasciitilde12.4\% (0\degree). To control the PWM signal from coming from the RPi using Python, we will actually be implementing software driven (as opposed to hardware driven) PWM. This means that we can map any of the RPi's GPIO to as many servos as there are GPIO, instead of only being able as many servos as there are PWM supported pins on a board. The draw back to software driven PWM is that it is only accurate within \SI{100}{\micro\second}, whereas hardware driven PWM is accurate within \SI{1}{\micro\second}. This innacuracy results in servo "jitter", but this can be mitigated with some techniques on the programming side. Now, as with the other Python sensor tests, get back into you RPi's command line and run the following to navigate back to your workspace:
    \codeb{Navigate to your workspace}
    {
      cd  /Desktop/python-code/test-scripts
    }
    The, create and edit a file using the same \textit{nano} editor used before:
    \codeb{Create servo Python testing script file}
    {
      nano servo-test.py
    }
    Now, copy and paste the following code into this file:
     \lstinputlisting[language=Python, caption=Script for testing the servo motor]{servo-test-tex.py}
    \note{When copying the above code, make sure that you do not copy the page number in between the two pages.}
    \newline
    \noindent
    Now save the file (\texttt{\textbf{control-O <enter> control-X}}) and run the script by executing the following in the command line:
    \codeb{Run the test script for the servo motor}
    {
      python servo-test.py
    }
    This should then output text indicating that a series of rotations were performed like the following:
    \outputb{Test script output for servo motor}
    {
      pi@raspberrypi:\textasciitilde/Desktop/python-code/test-scripts\$ python servo-test.py \\
      Rotated to 105\degree                                                        \\
      Rotated to 210\degree                                                        \\
      Rotated to 105\degree                                                        \\
      Rotated to 0\degree
    }
    And the servo motor should rotate between these points.
\subsection{Remote outputs}
The RPi will need some way to to send you feedback of its state (and the state of its environment) when you are not in its general vicinity. This is the meaning of a remote output.
  \subsubsection{Sending an email with Gmail and Python}
  One method for remote output is sending an email. Python makes this process very easy, in fact, no additional packages need to be installed for this to work. Everything that is required is already installed and configured on your RPi.
    \paragraph{Create a gmail account}
    This manual will be tailored to using a gmail smtp server, however a similar method can be used with other email providers. To authenticate into your gmail account from a Python script, you will need to change your security settings. This does change will make it easier for attackers to get into your account, so if you value your personal gmail account, it is suggested that you create a new, free one at \href{https://www.gmail.com}{https://www.gmail.com}.
    \paragraph{Enable "less secure apps"}
    To authenticate into your gmail account from a Python script, you need to turn on the "Access for less secure apps" setting in your gmail account here: \href{https://www.google.com/settings/security/lesssecureapps}{https://www.google.com/settings/security/lesssecureapps}. As mentioned in the previous section, this does less make your account more vulnerable to attacks, so it is advised that you create a new account. Make sure that when you enable this option via the above URL, you are logged in to the account you wish to use.
    \paragraph{Write and execute the Python script}
    To send the email from your RPi, navigate back into your workspace after once again accessing your RPi's command line.
    \codeb{Navigate to your workspace}
    {
      cd \textasciitilde/Desktop/python-code/test-scripts
    }
    Then, create and edit a file using the same \textit{nano} editor used before:
    \codeb{Create email Python testing script file}
    {
      nano email-test.py
    }
    Now, copy and paste the following code into this file:
    \lstinputlisting[language=Python, caption=Script for testing email]{email-test-tex.py}
    \note{When copying the above code, make sure that you do not copy the page number in between the two pages.}

    \newline
    \noindent
    Now save the file (\textbf{\texttt{control-O <enter> control-X}}) and run the script by executing the following in the command line:
    \codeb{Run the test script for email}{
      python email-test.py
    }
    You should then receive an email at the \textit{to\_address} you specified, after the script has finished running.
    
\section{Day 3: Improved Autonomy}
\subsection{The state machine}
A state machine is a programming model that discretely defines the behavior of a system over its lifetime. Simply put, it is where we define what our system does and when.
  \subsubsection{Designing the state machine}
  The are a number of types of state machines, but one of the more common, and the one we will use, is a Finite State Machine (FSM). Exactly as its name describes, an FSM has a finite number of states that can be transitioned to. Our state machine will also have the sub-classification of a Meally, where its current output(s) is/are determined by both the current input(s) and the current state. If you wish to find out more information on FSMs beyond the scope of this manual, this article has a very complete
    \paragraph{Outlining the high-level behavior}
    At a high-level, the state machine will function such that it outputs the following under the corresponding conditions.
    \begin{enumerate}
      \item 7 segment display:
        \begin{enumerate}
          \item Will alternate between displaying the current temperature and humidity, displaying each for 2 seconds before switching to the other. Humidity will have a precision of 2 after the decimal, and temperature will have a precision of 1 after the decimal.
          \item Upon a change of state (of the FSM) it will display the new state's 4-digit code for 3s, before returning back to displaying the humidity/temperature.
        \end{enumerate}
      \item Servo motor:
        \begin{enumerate}
          \item Begins at 105\degree rotation as a neutral position
          \item After entering the HOT or DRY state, it will rotate to 0\degree, hold for 3 seconds, then return to 105\degree
          \item After entering the COLD or WET state, it will rotate to 210\degree, hold for 3 seconds, then return to 105\degree
        \end{enumerate}
      \item Email:
        \begin{enumerate}
          \item Upon transitioning from the IDLE state to a WET/DRY/HOT/COLD state, it will email you such
          \item Upon transitioning from a WET/DRY/HOT/COLD state to the IDLE state, it will email you such
        \end{enumerate}
    \end{enumerate}
    \paragraph{The state diagram}
      The next step in the design is to synthesize these high-level behaviors into a finite set of states, transitions, inputs, and outputs that discretely define this behavior. The primary dangers in this step include \textbf{1) defining transitions based on combinations of inputs that aren't mutually exclusive} and \textbf{2) not spanning all possible combinations of inputs with the transitions defined}. If, for a state in which only $n$ boolean inputs are of concern, a transition doesn't evaulate for each $2^n$ possible combination of inputs, the FSM will exhibit undefined behavior. On the other hand, if each defined transition is not a unique combination of inputs, then it is possible for multiple defined transitions to evaluate which will also cause undefined behavior. Keeping these two dangers in mind, the following is a state diagram for the FSM we will use, with a fully spanned set of unique transitions for each state.
      \imagefigb{fsm-slab.png}{State diagram for Finite State Machine}
      \noindent
      \note{This system is in a fictional environment in which turning the servo clockwise (up) decreases humidity and increases temperature, and turning the servo counter-clockwise (down) increases humidity and decreases temperature. Also to note, inputs from the IDLE state corresponding to multiple of WET/COLD/HOT/DRY are not explicitly spanned by the transition conditions, but allowed to default to the first evaluated. (e.g. if (h > h\_wet\_thresh) AND (t < t\_cold\_thresh), the FSM will enter the WET state and not the COLD state)}
  \subsubsection{Implementing the state machine}
    \underline{\textit{Note}}: This section of the manual assume that you are no longer using the RPi in headless mode.
    \newline\newline \noindent
    To implement this state machine, first, download a zip contain the module code here:\newline \href{https://github.com/mmwebster/rpi-remote-monitoring-and-control}{https://github.com/mmwebster/rpi-remote-monitoring-and-control}. Then, copy the "code" directory into your python workspace. Now the only step necessary to run the entire FSM is to execute \codei{python main.py} in the command line.
    \paragraph{Implementing a .gitignore'd secrets.py}
    There is one last step required to implement the state machine such that you receive email alerts. You must create a \codei{secrets.py} file that contains your passwords and other credentials for your SMTP email. It should be in the code's top-level directory with the following form:
    \lstinputlisting[language=Python, caption=Example secrets.py]{example-secrets-tex.py}


  \subsubsection{Daemonizing the FSM (main.py)}
    \paragraph{Installing PM2}
    Run the following to update the RPi's packages and system, then install NPM and PM2:
    \codeb{Update RPi and install NPM and PM2}{
        sudo apt-get update \\
        sudo apt-get upgrade \\
        sudo apt-get install nodejs pm2 \\
        sudo npm install -g pm2 \\
    }
    \paragraph{Configuring PM2}
    You should now be able to view all of PM2's active processes by running \codei{pm2 list}. Now, to configure PM2 to automatically start the FSM when it boots up, generate PM2's startup script command:
    \codeb{Generate PM2's startup script command}{pm2 startup}
    Then, copy the outputted setup command and run it. It should have a form similar to the following:
    \outputb{Generate PM2's startup script}{sudo env PATH=\$PATH:/usr/bin /usr/local/lib/node\_modules/pm2/bin/pm2 startup systemd -u pi --hp /home/pi}
    \paragraph{Daemonizing main.py with PM2}
    Run the following commands to startup the FSM (main.py) and save it to the processes restarted on reboot:
    \codeb{Start FSM process; save it to reboot processes}{
        pm2 start ~/Desktop/slab/code/main.py -n fsm --interpreter=python \\
        pm2 save
    }
    \paragraph{General PM2 Commands}
    The following are useful PM2 commands for monitoring the processes its currently running:
    \begin{enumerate}
        \item \codei{pm2 list}: Lists all current processes
        \item \codei{pm2 stop <process-name>}: Stops the process <process-name>
        \item \codei{pm2 start <process/file-name>}: Restarts the process <process/file-name> if it's the name of a currently stopped process in PM2, otherwise it attempts to start a process for the given path.
        \item \codei{pm2 delete <process-name>}: Deletes the process (not the code, just the process) <process-name>
    \end{enumerate}


\subsection{Data Analysis}
Some simple data recording and analysis can be performed by outputting sensor data to a CSV file with Python. From there it is trivial to import into Excel or Google Sheets to perform analysis as desired. To do this, we will save sensor data into a separate file for every day, in which will be the fields time (timestamp), humidity (\%), and temperature.(\degree C).
  \subsubsection{Saving \& Emailing CSV sensor w/ Python}
  We will modify the previous state machine code to include a few lines to append to a CSV file with the current sensor data every 8 seconds, which will result in about 10k entries in every day's CSV file. First, following this tutorial to understand how the CSV module works in python:
  \href{http://www.pythonforbeginners.com/systems-programming/using-the-csv-module-in-python/}{http://www.pythonforbeginners.com/systems-programming/using-the-csv-module-in-python/}.
  Now, modify main.py with the following additions:
  \begin{enumerate}
      \item Import the CSV module at the top of the file
      \item Write temperature and humidity data to the end of the file during every iteration of the state machine
      \item In the main FSM runloop, email yourself with the sensor CSV data file attached using the provided Mailer class.
  \end{enumerate}
\subsection{Conclusion and Troubleshooting}
  You should now be able to remotely monitor and control a system using a Raspberry Pi 3 and the additional materials detailed in this manual. If you have any questions, do your best to format them to only require yes or no answers, and then google them! StackOverflow.com and other online coding forums will be your best friends. More often than not, any problem you're experiencing has already been documented and solved online; go find it and don't rely on your lab instructor!
% \subsection{Appendix}
\begin{appendices}
%  An Appendix contains information that is non-essential to understanding of the paper, but may present information that further clarifies a point without burdening the body of the presentation
  \subsection{Suggested Material Vendors}
    \imagefigs{resources/material-images/vendor-rpi}{Raspberry Pi 3 Model B (Most of this manual will apply to other versions and models as well, however it is tailored to this particular version and model of the RPi.) \href{https://www.sparkfun.com/products/13825}{https://www.sparkfun.com/products/13825} \label{sec:vendor-rpi}}
    \imagefigs{resources/material-images/vendor-micro-sd}{Micro SD Card (at least 8GB in size) \href{https://www.sparkfun.com/products/13833}{https://www.sparkfun.com/products/13833}
          \label{sec:vendor-sd}}
    \imagefigs{resources/material-images/vendor-ttl-serial-cable}{USB to TTL Serial Cable (aka Console Cable) \href{https://www.sparkfun.com/products/12977}{https://www.sparkfun.com/products/12977}
          \label{sec:vendor-usbttlserial}}
    \imagefigs{resources/material-images/vendor-usb-micro-cable}{USB to Micro USB Cable \href{https://www.sparkfun.com/products/10767}{https://www.sparkfun.com/products/10767}
          \label{sec:vendor-usbmusb}}
    \imagefigs{resources/material-images/vendor-si7021}{Humidity and Termperature Sensor \href{https://www.sparkfun.com/products/13763}{https://www.sparkfun.com/products/13763}
          \label{sec:vendor-sensor}}
    \imagefigs{resources/material-images/vendor-seg7}{7-Segment Display \href{https://www.sparkfun.com/products/11442}{https://www.sparkfun.com/products/11442}
          \label{sec:vendor-7seg}}
    \imagefigs{resources/material-images/vendor-servo}{Servo Motor \href{https://www.sparkfun.com/products/9065}{https://www.sparkfun.com/products/9065}
          \label{sec:vendor-servo}}
    \imagefigs{resources/material-images/vendor-breadboard}{Breadboard \href{https://www.sparkfun.com/products/12002}{https://www.sparkfun.com/products/12002}
          \label{sec:vendor-breadboard}}
    \imagefigs{resources/material-images/vendor-f-f-jumper}{Jumper Wires: Female/Female \href{https://www.sparkfun.com/products/12796}{https://www.sparkfun.com/products/12796}}
    \imagefigs{resources/material-images/vendor-f-m-jumper}{Jumper Wires: Male/Female \href{https://www.sparkfun.com/products/12794}{https://www.sparkfun.com/products/12794}}
    \imagefigs{resources/material-images/vendor-m-m-jumper}{Jumper Wires: Male/Male \href{https://www.sparkfun.com/products/12795}{https://www.sparkfun.com/products/12795}}
    \label{sec:vendor-wires}
    \imagefigs{resources/material-images/vendor-battery-holder}{4xAA Battery Holder \href{https://www.sparkfun.com/products/552}{https://www.sparkfun.com/products/552}
          \label{sec:vendor-batholder}}
\end{appendices}
%   \includegraphics[width=\textwidth]{jpg.jpg}
%   \includepdf[pages={1-3}]{pdf.pdf}
\end{document}
